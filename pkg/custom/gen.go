package custom

import (
	"bytes"
	"fmt"
	"go/format"
	"io"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"sigs.k8s.io/controller-tools/pkg/genall"
	"sigs.k8s.io/controller-tools/pkg/loader"
	"sigs.k8s.io/controller-tools/pkg/markers"
)

type Generator struct {
	// Name - placeholder for now
	Name string
}

type result struct {
	Group string
	Type  string
	Info  markers.TypeInfo
}

func (g Generator) Generate(ctx *genall.GenerationContext) error {
	_, err := GenerateHelper(ctx)
	if err != nil {
		return err
	}

	// var output string
	// for _, r := range res {
	// 	output = output + fmt.Sprintf("Extracted values types: %s Groups: %s \n", r.Info.Name, r.Type)
	// }

	// for _, root := range ctx.Roots {
	// 	err := writeOut(ctx, root, []byte(output))
	// 	if err != nil {
	// 		return err
	// 	}
	// }
	return nil
}

func GenerateHelper(ctx *genall.GenerationContext) ([]result, error) {
	var out []result

	for _, root := range ctx.Roots {
		root.NeedTypesInfo()

		byType := make(map[string][]byte)
		imports := &importsList{
			byPath:  make(map[string]string),
			byAlias: make(map[string]string),
			pkg:     root,
		}

		// avoid confusing aliases by "reserving" the root package's name as an alias
		imports.byAlias[root.Name] = ""

		if err := markers.EachType(ctx.Collector, root, func(info *markers.TypeInfo) {
			outContent := new(bytes.Buffer)
			r := result{
				Info: *info,
			}
			out = append(out, r)

			configCtx := &configMethodWriter{
				importsList: imports,
				pkg:         *root,
				codeWriter:  &codeWriter{out: outContent},
			}

			// if not enabled for this type, skip
			if !isEnabledForMethod(info) {
				return
			}

			configCtx.GenerateConfigMethod(root, info)

			outBytes := outContent.Bytes()
			if len(outBytes) > 0 {
				byType[info.Name] = outBytes
			}
		}); err != nil {
			return nil, err
		}

		if len(byType) == 0 {
			return nil, nil
		}

		outContent := new(bytes.Buffer)
		writeHeader(root, outContent, root.Name, imports)
		writeMethods(root, outContent, byType)

		outBytes := outContent.Bytes()
		formattedBytes, err := format.Source(outBytes)
		if err != nil {
			root.AddError(err)
			// we still write the invalid source to disk to figure out what went wrong
		} else {
			outBytes = formattedBytes
		}

		err = writeOut(ctx, root, outBytes)
		if err != nil {
			return nil, err
		}
	}

	return out, nil
}

func writeMethods(pkg *loader.Package, out io.Writer, byType map[string][]byte) {
	soretedNames := make([]string, 0, len(byType))
	for name := range byType {
		soretedNames = append(soretedNames, name)
	}
	sort.Strings(soretedNames)

	for _, name := range soretedNames {
		_, err := out.Write(byType[name])
		if err != nil {
			// expose this error
			pkg.AddError(err)
		}
	}
}

func (g Generator) RegisterMarkers(into *markers.Registry) error {
	if err := into.Register(RuleDefinition); err != nil {
		return err
	}
	// Skipping adding Help for this marker for now
	return nil
}

// Wire in output rules instead of creating a file in here. Use pkg/genall/output.go
func writeOut(ctx *genall.GenerationContext, root *loader.Package, outbytes []byte) error {

	wd, err := os.Getwd()
	if err != nil {
		return err
	}

	path := filepath.Join(wd, "zz_generated_test.go")

	outputFile, err := os.Create(path)
	if err != nil {
		return err
	}

	defer outputFile.Close()

	n, err := outputFile.Write(outbytes)
	if err != nil {
		return err
	}

	if n < len(outbytes) {
		return err
	}

	return nil
}

// importsList keeps track of required imports, automatically assigning aliases
// to import statement.
type importsList struct {
	byPath  map[string]string
	byAlias map[string]string

	pkg *loader.Package
}

func writeHeader(pkg *loader.Package, out io.Writer, packageName string, imports *importsList) {
	_, err := fmt.Fprintf(out, `// +build !ignore_autogenerated

// Code generated by controller-gen. DO NOT EDIT.

package %[1]s

import (
%[2]s
)

`, packageName, strings.Join(imports.ImportSpecs(), "\n"))
	if err != nil {
		pkg.AddError(err)
	}
}

// isEnabledForMethod verifies if the genclient marker is enabled for
// this type or not
func isEnabledForMethod(info *markers.TypeInfo) bool {
	enabled := info.Markers.Get(RuleDefinition.Name)
	return enabled != nil
}
