// +build !ignore_autogenerated

// Code generated by controller-gen. DO NOT EDIT.

package generated


import (
	"ctx"
	appsapiv1 "github.com/varshaprasad96/client-gen/testdata/pkg/apis/apps/v1"
	appsv1 "k8s.io/client-go/kubernetes/typed/apps/v1"

	"github.com/kcp-dev/kcp-client-wrappers/kcp"
)

type wrappedAppsV1 struct {
	cluster  string
	delegate appsv1.AppsV1Interface
}

func (w *wrappedAppsV1) RESTClient() rest.Interface {
	return w.delegate.RESTClient()
}

func (w *wrappedapps) checkCluster(ctx context.Context) (context.Context, error) {
	ctxCluster, ok := kcp.ClusterFromContext(ctx)
	if !ok {
		return kcp.WithCluster(ctx, w.cluster), nil
	} else if ctxCluster != w.cluster {
		return ctx, fmt.Errorf("cluster mismatch: context=%q, client=%q", ctxCluster, w.cluster)
	}
	return ctx, nil
}

func (w *wrappedAppsV1) Deployments() appsv1.DeploymentInterface {
	return &wrappedDeployment{
		cluster:  w.cluster,
		delegate: w.delegate.Deployments(),
	}
}

type wrappedDeployment struct {
	cluster  string
	delegate apps.DeploymentInterface
}

func (w *wrappedDeployment) Create(ctx context.Context, deployment *appsapiv1.Deployment, opts metav1.CreateOptions) (*appsapiv1.Deployment, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Create(ctx, deployment}, opts)
}

func (w *wrappedDeployment) Update(ctx context.Context, deployment} *appsapiv1.Deployment, opts metav1.UpdateOptions) (*appsapiv1.Deployment, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Update(ctx, deployment}, opts)
}

func (w *wrappedDeployment) Delete(ctx context.Context, name string, opts metav1.DeleteOptions) error {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Delete(ctx, name, opts)
}

func (w *wrappedDeployment) DeleteCollection(ctx context.Context, opts metav1.DeleteOptions, listOpts metav1.ListOptions) error {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Delete(ctx, opts, listOpts)
}

func (w *wrappedDeployment) Get(ctx context.Context, name string, opts metav1.GetOptions) (*appsapiv1.Deployment, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Get(ctx, opts, listOpts)
}

func (w *wrappedDeployment) List(ctx context.Context, opts metav1.ListOptions) (*appsapiv1.DeploymentList, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.List(ctx, opts)
}

func (w *wrappedDeployment) Watch(ctx context.Context, opts metav1.ListOptions) (watch.Interface, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Watch(ctx, opts)
}

func (w *wrappedDeployment) Patch(ctx context.Context, name string, pt apiTypes.PatchapiType, data []byte, opts metav1.PatchOptions, subresources ...string) (result *appsapiv1.Deployment, err error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Patch(ctx, name, pt, data, opts, subresources)
}
