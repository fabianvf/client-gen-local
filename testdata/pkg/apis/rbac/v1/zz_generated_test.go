// +build !ignore_autogenerated

// Code generated by controller-gen. DO NOT EDIT.

package v1

import (

)


// NewForConfig creates a new Clientset for the given config.
// If config's RateLimiter is not set and QPS and Burst are acceptable, 
// NewForConfig will generate a rate-limiter in configShallowCopy.
// NewForConfig is equivalent to NewForConfigAndClient(c, httpClient),
// where httpClient was generated with rest.HTTPClientFor(c).
func NewForConfig(c *rest.Config) (*ClusterClient, error) {
	client, err := rest.HTTPClientFor(config)
	if err != nil {
		return nil, fmt.Errorf("error creating HTTP client: %!w(MISSING)", err)
	}

	clusterRoundTripper := kcp.NewClusterRoundTripper(client.Transport)
	client.Transport = clusterRoundTripper

	delegate, err := kubernetes.NewForConfigAndClient(config, client)
	if err != nil {
		return nil, fmt.Errorf("error creating delegate clientset: %!w(MISSING)", err)
	}

	return &ClusterClient{
		delegate: delegate,
	}, nil

}

import (
	rbacapiv1 "github.com/varshaprasad96/client-gen/testdata/pkg/apis/rbac/v1"
	rbacv1 "github.com/varshaprasad96/client-gen/testdata"
)

func NewForConfig(config *rest.Config) (*ClusterClient, error) {
	client, err := rest.HTTPClientFor(config)
	if err != nil {
		return nil, fmt.Errorf("error creating HTTP client: %w", err)
	}

	clusterRoundTripper := kcp.NewClusterRoundTripper(client.Transport)
	client.Transport = clusterRoundTripper

	delegate, err := kubernetes.NewForConfigAndClient(config, client)
	if err != nil {
		return nil, fmt.Errorf("error creating delegate clientset: %w", err)
	}

	return &ClusterClient{
		delegate: delegate,
	}, nil
}

type ClusterClient struct {
	delegate kubernetes.Interface
}

func (c *ClusterClient) Cluster(cluster string) kubernetes.Interface {
	return &wrappedInterface{
		cluster:  cluster,
		delegate: c.delegate,
	}
}

type wrappedInterface struct {
	cluster  string
	delegate kubernetes.Interface
}

func (w *wrappedInterface) RbacV1() rbacv1.RbacV1Interface {
	return &wrappedRbacV1{
		cluster:  w.cluster,
		delegate: w.delegate.RbacV1,
	}
}

type wrappedRbacV1 struct {
	cluster  string
	delegate rbacv1.RbacV1Interface
}

func (w *wrappedRbacV1) RESTClient() rest.Interface {
	//TODO
	panic("no")
}

func (w *wrappedRbacV1) ClusterRoles() rbacv1.ClusterRoleInterface {
	return &wrappedClusterRole{
		cluster:  w.cluster,
		delegate: w.delegate.ClusterRoles(),
	}
}

type wrappedClusterRole struct {
	cluster  string
	delegate rbac.ClusterRoleInterface
}

func (w *wrappedInterface) RbacV1() rbacv1.RbacV1Interface {
	return &wrappedRbacV1{
		cluster:  w.cluster,
		delegate: w.delegate.RbacV1(),
	}
}

func (w *wrappedClusterRole) checkCluster(ctx context.Context) (context.Context, error) {
	ctxCluster, ok := kcp.ClusterFromContext(ctx)
	if !ok {
		return kcp.WithCluster(ctx, w.cluster), nil
	} else if ctxCluster != w.cluster {
		return ctx, fmt.Errorf("cluster mismatch: context=%q, client=%q", ctxCluster, w.cluster)
	}
	return ctx, nil
}

func (w *wrappedClusterRole) Create(ctx context.Context, clusterRole *rbacapiv1.ClusterRole, opts metav1.CreateOptions) (*rbacapiv1.ClusterRole, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Create(ctx, clusterRole}, opts)
}

func (w *wrappedClusterRole) Update(ctx context.Context, clusterRole} *rbacapiv1.ClusterRole, opts metav1.UpdateOptions) (*rbacapiv1.ClusterRole, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Update(ctx, clusterRole}, opts)
}

func (w *wrappedClusterRole) Delete(ctx context.Context, name string, opts metav1.DeleteOptions) error {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Delete(ctx, name, opts)
}

func (w *wrappedClusterRole) DeleteCollection(ctx context.Context, opts metav1.DeleteOptions, listOpts metav1.ListOptions) error {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Delete(ctx, opts, listOpts)
}

func (w *wrappedClusterRole) Get(ctx context.Context, name string, opts metav1.GetOptions) (*rbacapiv1.ClusterRole, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Get(ctx, opts, listOpts)
}

func (w *wrappedClusterRole) List(ctx context.Context, opts metav1.ListOptions) (*rbacapiv1.ClusterRoleList, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.List(ctx, opts)
}

func (w *wrappedClusterRole) Watch(ctx context.Context, opts metav1.ListOptions) (watch.Interface, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Watch(ctx, opts)
}

func (w *wrappedClusterRole) Patch(ctx context.Context, name string, pt apiTypes.PatchapiType, data []byte, opts metav1.PatchOptions, subresources ...string) (result *rbacapiv1.ClusterRole, err error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Patch(ctx, name, pt, data, opts, subresources)
}
